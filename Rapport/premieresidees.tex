\section{Premières Idées}
A l'abordage du problème nous avons tout de suite remarqué la fonction \verb!setFromString(String s)! qui prend en paramètre un String de chiffres et crée la solution correspondante. Il nous est tout de suite venu à l'idée d'utiliser cette fonction en conjonction à une génération de nombres aléatoires pour générer des solutions aléatoires. Ceci a donné la fonction \verb!randomize()!.

\subsection{Aléatoire pur}
\begin{java}
public void randomize() {
	int i = slpb.getNp();
	int j;

	while (i != 0) {
		Random r = new Random();
		j = r.nextInt(i) + 1;
		i -= j;
	
		addProductionLast(j);
	}

	i = slpb.getNp();
	while (i != 0) {
		Random r = new Random();
		j = r.nextInt(i) + 1;
	
		if(j<=slpb.getTransporter().capacity) {
			i -= j;
			addDeliveryLast(j);
		}
	}
	//System.out.println(productionSequenceMT + "|" + deliverySequenceMT + " => " + evaluate());
}
\end{java}
\vspace{1em}
Cette fonction a pour but de générer simplement une solution aléatoire. On peut l'évaluer ensuite avec la fonction \verb!evaluate()! qui était donné dans le code original. Le seul test fait ici est de faire en sorte que les batchs de livraison de soient pas plus grands que la capacité du transporteur.
\vspace{2em}

\subsection{Aléatoire "contrôlé"}
Par la suite, au fur et à mesure des tests de cette fonction, nous avons pris conscience de la puissance de la générations aléatoire. En effet, plusieurs itérations du problème avec cette seule fonction de génération aléatoire nous donnaient quelques solutions pas trop mauvaises pour de petites instances. Nous nous sommes alors dit qu'il serait intéressant d'implémenter un algorithme évolutionniste, dont un des grands composants est l'Aléatoire. Mais avant cela, nous avons élaborer une seconde fonction de génération, qui génère des solutions dont le nombre de batchs est plus élevé, et donc la quantité par batch plus petite.

\begin{java}
public void randomize2() {
	int nb_products = slpb.getNp();
	int i, current_products, max;
	Random r = new Random();
	
	current_products = 0;
	max = nb_products / 4;
	while (current_products < nb_products) {
		i = r.nextInt(max + r.nextInt(max)) + 1;
		
		if (current_products + i > nb_products) {
			i = nb_products - current_products;
		}
		
		addProductionLast(i);
		current_products += i;
	}
	
	current_products = 0;
	max = nb_products / 4;
	while (current_products < nb_products) {
		i = r.nextInt(max + r.nextInt(max)) + 1;
		
		if (current_products + i > nb_products) {
			i = nb_products - current_products;
		}
		
		if(i<=slpb.getTransporter().capacity) {
			addDeliveryLast(i);
			current_products += i;
		}
	}
	
	//System.out.println(productionSequenceMT + "|" + deliverySequenceMT + " => " + evaluate());
}

\end{java}
\vspace{1em}
Par la combinaison de ces deux générations on obtient une assez grande variété de solutions. C'est donc ainsi que nous avons décidé de construire la population de l'algorithme évolutionniste.